/*
 * generated by Xtext 2.30.0
 */
package de.tud.st.featurelang.generator

import de.tud.st.featurelang.featureLang.AssociationAction
import de.tud.st.featurelang.featureLang.AttributeAction
import de.tud.st.featurelang.featureLang.InheritanceAction
import de.tud.st.featurelang.featureLang.PriorityValue
import de.tud.st.featurelang.featureLang.UpdateAction
import org.eclipse.emf.ecore.EObject
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import de.tud.st.featurelang.featureLang.CreationStatement
import de.tud.st.featurelang.featureLang.ChangeStatement
import de.tud.st.featurelang.featureLang.Statement
import de.tud.st.featurelang.featureLang.CompositionAction
import de.tud.st.featurelang.featureLang.Abstraction
import de.tud.st.featurelang.featureLang.IdentifierValue
import de.tud.st.featurelang.featureLang.SetCompatible
import de.tud.st.featurelang.featureLang.SetVersionRange
import de.tud.st.featurelang.featureLang.SetVariant
import de.tud.st.featurelang.featureLang.SetRightOpen
import de.tud.st.featurelang.featureLang.SetLeftOpen
import de.tud.st.featurelang.featureLang.Publicity

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
 
 // @author Karl Kegel 2023
 
class FeatureLangGenerator extends AbstractGenerator {

	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		val result = resource.allContents
				.filter(Statement)
				.map[compileStatement]
				.join("&\n");
		System.out.println(">>>")
		System.out.println(result)
		System.out.println("<<<")
		fsa.generateFile("evolution.txt", result);
	}
	
	private def compileStatement(Statement s){
		switch s {
			ChangeStatement : s.compile
			CreationStatement : s.compile
			default : 'NOP'
		}
	}
	
	private def compile(ChangeStatement s) '''
		«val should = s.getPriority() !== null && s.getPriority().getPriority() === PriorityValue.SHOULD»
		«IF should»
				START OPTIONAL,
		«ENDIF»
		OPEN CLASS «s.getTarget().name»/CLOSE CLASS «s.getTarget().name»,
		«IF s.getAction() !== null »
			«s.getAction().getType().compileAction(s.isNegation())»
		«ELSEIF s.getUpdate() !== null»
			«s.getUpdate().compileUpdate()»
		«ENDIF»
		CLOSE CLASS «s.getTarget().name»/OPEN CLASS «s.getTarget().name»,
		«IF should»
				END OPTIONAL,
		«ENDIF»
    '''
    
    private def compile(CreationStatement s)'''
		«val should = s.getPriority() !== null && s.getPriority().getPriority() === PriorityValue.SHOULD»
		«val name = s.getClassElement().getName()»
		«val abstraction = s.getClassElement().getAbstraction() === Abstraction.ABSTRACTION»
		«IF should»
			START OPTIONAL,
		«ENDIF»
		«IF s.isNegation() »
			DELETE CLASS «name»/CREATE CLASS «name»,
		«ELSE»
			«IF abstraction» 
				CREATE ABSTRACT CLASS «name»/DELETE CLASS «name»,
			«ELSE»	
				CREATE CLASS «name»/DELETE CLASS «name»,
			«ENDIF»	
		«ENDIF»
		«IF should»
			END OPTIONAL,
		«ENDIF»
    '''
    
	private def compileAction(EObject a, boolean negation){
		switch a {
			AttributeAction : a.compileAttributeAction(negation)
			AssociationAction : a.compileAssociationAction(negation)
			InheritanceAction : a.compileInheritanceAction(negation)
			CompositionAction : a.compileCompositionAction(negation)
			default : 'NOP'
		}
	}
	
	private def compileAttributeAction(AttributeAction a, boolean negation){
		val attr =  a.getAttribute()
		val attrName = attr.getName()
		'''
		«IF negation»
			DELETE ATTRIBUTE «attrName»/ADD ATTRIBUTE «attrName»,
		«ELSE»
			ADD ATTRIBUTE «attrName»/DELETE ATTRIBUTE «attrName»,
			OPEN ATTRIBUTE «attrName»,
			«IF a.getType() === null»
				SET TYPE DEFAULT,
			«ELSE»
				SET TYPE «a.getType()»,
			«ENDIF»
			«IF a.getValue() !== null»
				«val value = a.getValue()»
				«IF value !== null» 
					SET ATTRIBUTE VALUE TO «value»,
				«ENDIF»	
			«ENDIF»	
			CLOSE ATTRIBUTE «attrName»,
		«ENDIF»
		'''
	}
	
	private def compileAssociationAction(AssociationAction a, boolean negation){
		'''
		«IF a.getCreate() !== null»
			«val targetClass = a.getCreate().getTarget().getName()»
			«val relation = a.getCreate().getRelation()»
			«IF negation»
				DELETE ASSOCIATION «relation»/ADD ASSOCIATION «relation» TARGET «targetClass»,
			«ELSE»
				ADD ASSOCIATION «relation» TARGET «targetClass»/DELETE ASSOCIATION «relation»,
			«ENDIF» 
		«ELSE» 
			«val associationName = a.getName()»
			OPEN ASSOCIATION «associationName»/CLOSE ASSOCIATION «associationName»,
			«a.getEdit().getType().compileEditAssociation(negation)»
			CLOSE ASSOCIATION «associationName»/OPEN ASSOCIATION «associationName»,
		«ENDIF»
		'''
	}
	
	private def compileEditAssociation(EObject a, boolean negation){
		switch a {
			SetCompatible : a.compileSetCompatible(negation)
			SetVersionRange : a.compileSetVersionRange(negation)
			SetVariant : a.compileSetVariant(negation)
			SetLeftOpen : a.compileSetLeftOpen(negation)
			SetRightOpen : a.compileSetRightOpen(negation)
			default : 'NOP'
		}
	}
	
	private def compileSetCompatible(SetCompatible a, boolean negation) {
		val versionName = a.getName() 
		'''
		«IF negation»
			REMOVE COMPATIBLE WITH VERSION «versionName»/SET COMPATIBLE WITH VERSION «versionName»,
		«ELSE» 
			SET COMPATIBLE WITH VERSION «versionName»/REMOVE COMPATIBLE WITH VERSION «versionName»,
		«ENDIF»
		'''	
	}
	
	private def compileSetVersionRange(SetVersionRange a, boolean negation) {
		val start = a.getStart()
		val end = a.getEnd() 
		'''
		«IF negation»
			REMOVE VERSION RANGE FROM «start» TO «end»/SET VERSION RANGE FROM «start» TO «end»,
		«ELSE» 
			SET VERSION RANGE FROM «start» TO «end»/REMOVE VERSION RANGE FROM «start» TO «end»,
		«ENDIF»
		'''	
	}
	
	private def compileSetVariant(SetVariant a, boolean negation) {
		val variantDate = a.getName()
		'''
		«IF negation»
			REMOVE COMPATIBLE WITH ALL VERSIONS OF VARIANT «variantDate»/SET COMPATIBLE WITH ALL VERSIONS OF VARIANT «variantDate»,
		«ELSE» 
			SET COMPATIBLE WITH ALL VERSIONS OF VARIANT «variantDate»/REMOVE COMPATIBLE WITH ALL VERSIONS OF VARIANT «variantDate»,
		«ENDIF»
		'''	
	}
	
	private def compileSetLeftOpen(SetLeftOpen a, boolean negation) {
		val date = a.getDate()
		'''
		«IF negation»
			REMOVE VERSION UP TO DATE «date»/SET VERSION UP TO DATE «date»,
		«ELSE» 
			SET VERSION UP TO DATE «date»/REMOVE VERSION UP TO DATE «date»,
		«ENDIF»
		'''	
	}
	
	private def compileSetRightOpen(SetRightOpen a, boolean negation) {
		val date = a.getDate()
		'''
		«IF negation»
			REMOVE VERSION STARTING FROM DATE «date»/SET VERSION STARTING FROM DATE «date»,
		«ELSE» 
			SET VERSION STARTING FROM DATE «date»/REMOVE VERSION STARTING FROM DATE «date»,
		«ENDIF»
		'''	
	}
	
	private def compileCompositionAction(CompositionAction a, boolean negation) {
		'''
		«IF a.getCreate() !== null»
			«val targetClass = a.getCreate().getTarget().getName()»
			«val relation = a.getCreate().getRelation()»
			«IF negation»
				DELETE COMPOSITION «relation»/ADD COMPOSITION «relation» TARGET «targetClass»,
			«ELSE»
				ADD COMPOSITION «relation» TARGET «targetClass»/DELETE COMPOSITION «relation»,
				«IF a.getCreate().getPublicity() !== null»
					«val should = a.getCreate().getPriority() !== null && a.getCreate().getPriority().getPriority() === PriorityValue.SHOULD»	
					«IF should»
						START OPTIONAL,
					«ENDIF»
					«val public = a.getCreate().getPublicity() === Publicity.PUBLIC»
					«IF public»
						MAKE COMPOSITION PUBLIC,
					«ELSE» 
						MAKE COMPOSITION PRIVATE,
					«ENDIF»
					«IF should»
						END OPTIONAL,
					«ENDIF»	
				«ENDIF»	
			«ENDIF»
		«ELSE» 
			«val compositionName = a.getEdit().getCompositionName()»
			OPEN COMPOSITION «compositionName»/CLOSE COMPOSITION «compositionName»,
			«val public = a.getCreate().getPublicity() === Publicity.PUBLIC»
			«IF public»
				MAKE COMPOSITION PUBLIC/MAKE COMPOSITION PRIVATE,
			«ELSE» 
				MAKE COMPOSITION PRIVATE/MAKE COMPOSITION PUBLIC,
			«ENDIF»
			CLOSE COMPOSITION «compositionName»/OPEN COMPOSITION «compositionName»,
		«ENDIF»	
		'''
	}
	
	private def compileInheritanceAction(InheritanceAction a, boolean negation){
		'''
		«val targetClass = a.getParent().getName()»
		«IF negation»
			DELETE PARENT_RELATION «targetClass»/ADD PARENT_RELATION «targetClass»,
		«ELSE»
			ADD PARENT_RELATION «targetClass»/DELETE PARENT_RELATION «targetClass»,
		«ENDIF»	
		'''
	}
	
	private def compileUpdate(UpdateAction a) '''
		«val should = a.getPriority() !== null && a.getPriority().getPriority() === PriorityValue.SHOULD»
		«val changeType = a.getDatatype() !== null»
		«val changeIdentifier = a.getIdentifier() !== null»
		«IF should»
		START OPTIONAL,
		«ENDIF» 
		OPEN ATTRIBUTE «a.getAttribute().getName()»/CLOSE ATTRIBUTE «a.getAttribute().getName()»,
		«IF changeType»
			SET TYPE «a.getDatatype().getType()»/SET TYPE «a.getDatatype().getOldType()»,
			CLOSE ATTRIBUTE «a.getAttribute().getName()»/OPEN ATTRIBUTE «a.getAttribute().getName()»,
		«ELSEIF changeIdentifier» 
			«val identifier = a.getIdentifier().getIdentifier()»
			«val nameId = identifier.getValue() === IdentifierValue.NAME»
			«val newIdentifier = identifier.getName()»
			«val oldIdentifier = a.getIdentifier().getOldIdentifier().getName()»
			«IF nameId»
				CHANGE ATTRIBUTE NAME TO «newIdentifier»/CHANGE ATTRIBUTE NAME TO «oldIdentifier»,
				CLOSE ATTRIBUTE «newIdentifier»/OPEN ATTRIBUTE «newIdentifier»,
			«ELSE» 
				CHANGE ATTRIBUTE URI TO «newIdentifier»/CHANGE ATTRIBUTE URI TO «oldIdentifier»,
				CLOSE ATTRIBUTE «a.getAttribute().getName()»/OPEN ATTRIBUTE «a.getAttribute().getName()»,
			«ENDIF»	
		«ELSE»
			«val value = a.getValue().getValue()»
			«val oldValue = a.getValue().getOldValue()»
			SET ATTRIBUTE VALUE TO «value»/SET ATTRIBUTE VALUE TO «oldValue»,
			CLOSE ATTRIBUTE «a.getAttribute().getName()»/OPEN ATTRIBUTE «a.getAttribute().getName()»,
		«ENDIF»	
		«IF should»
		END OPTIONAL,
		«ENDIF»
	'''
}
