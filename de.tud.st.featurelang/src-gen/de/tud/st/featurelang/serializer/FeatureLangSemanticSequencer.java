/*
 * generated by Xtext 2.32.0
 */
package de.tud.st.featurelang.serializer;

import com.google.inject.Inject;
import de.tud.st.featurelang.featureLang.AssociationAction;
import de.tud.st.featurelang.featureLang.Attribute;
import de.tud.st.featurelang.featureLang.AttributeAction;
import de.tud.st.featurelang.featureLang.ChangeStatement;
import de.tud.st.featurelang.featureLang.CompositionAction;
import de.tud.st.featurelang.featureLang.CreateAssociation;
import de.tud.st.featurelang.featureLang.CreateComposition;
import de.tud.st.featurelang.featureLang.CreationStatement;
import de.tud.st.featurelang.featureLang.EditAssociation;
import de.tud.st.featurelang.featureLang.EditComposition;
import de.tud.st.featurelang.featureLang.FeatureLangPackage;
import de.tud.st.featurelang.featureLang.FeatureRequest;
import de.tud.st.featurelang.featureLang.Identifier;
import de.tud.st.featurelang.featureLang.InheritanceAction;
import de.tud.st.featurelang.featureLang.Priority;
import de.tud.st.featurelang.featureLang.SetCompatible;
import de.tud.st.featurelang.featureLang.SetLeftOpen;
import de.tud.st.featurelang.featureLang.SetRightOpen;
import de.tud.st.featurelang.featureLang.SetVariant;
import de.tud.st.featurelang.featureLang.SetVersionRange;
import de.tud.st.featurelang.featureLang.UpdateAction;
import de.tud.st.featurelang.featureLang.UpdateAttributeDatatype;
import de.tud.st.featurelang.featureLang.UpdateAttributeIdentifier;
import de.tud.st.featurelang.featureLang.UpdateAttributeValue;
import de.tud.st.featurelang.services.FeatureLangGrammarAccess;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class FeatureLangSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private FeatureLangGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == FeatureLangPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case FeatureLangPackage.ACTION:
				sequence_Action(context, (de.tud.st.featurelang.featureLang.Action) semanticObject); 
				return; 
			case FeatureLangPackage.ASSOCIATION_ACTION:
				sequence_AssociationAction(context, (AssociationAction) semanticObject); 
				return; 
			case FeatureLangPackage.ATTRIBUTE:
				sequence_Attribute(context, (Attribute) semanticObject); 
				return; 
			case FeatureLangPackage.ATTRIBUTE_ACTION:
				sequence_AttributeAction(context, (AttributeAction) semanticObject); 
				return; 
			case FeatureLangPackage.CHANGE_STATEMENT:
				sequence_ChangeStatement(context, (ChangeStatement) semanticObject); 
				return; 
			case FeatureLangPackage.CLASS:
				sequence_Class(context, (de.tud.st.featurelang.featureLang.Class) semanticObject); 
				return; 
			case FeatureLangPackage.COMPOSITION_ACTION:
				sequence_CompositionAction(context, (CompositionAction) semanticObject); 
				return; 
			case FeatureLangPackage.CREATE_ASSOCIATION:
				sequence_CreateAssociation(context, (CreateAssociation) semanticObject); 
				return; 
			case FeatureLangPackage.CREATE_COMPOSITION:
				sequence_CreateComposition(context, (CreateComposition) semanticObject); 
				return; 
			case FeatureLangPackage.CREATION_STATEMENT:
				sequence_CreationStatement(context, (CreationStatement) semanticObject); 
				return; 
			case FeatureLangPackage.EDIT_ASSOCIATION:
				sequence_EditAssociation(context, (EditAssociation) semanticObject); 
				return; 
			case FeatureLangPackage.EDIT_COMPOSITION:
				sequence_EditComposition(context, (EditComposition) semanticObject); 
				return; 
			case FeatureLangPackage.FEATURE_REQUEST:
				sequence_FeatureRequest(context, (FeatureRequest) semanticObject); 
				return; 
			case FeatureLangPackage.IDENTIFIER:
				sequence_Identifier(context, (Identifier) semanticObject); 
				return; 
			case FeatureLangPackage.INHERITANCE_ACTION:
				sequence_InheritanceAction(context, (InheritanceAction) semanticObject); 
				return; 
			case FeatureLangPackage.PRIORITY:
				sequence_Priority(context, (Priority) semanticObject); 
				return; 
			case FeatureLangPackage.SET_COMPATIBLE:
				sequence_SetCompatible(context, (SetCompatible) semanticObject); 
				return; 
			case FeatureLangPackage.SET_LEFT_OPEN:
				sequence_SetLeftOpen(context, (SetLeftOpen) semanticObject); 
				return; 
			case FeatureLangPackage.SET_RIGHT_OPEN:
				sequence_SetRightOpen(context, (SetRightOpen) semanticObject); 
				return; 
			case FeatureLangPackage.SET_VARIANT:
				sequence_SetVariant(context, (SetVariant) semanticObject); 
				return; 
			case FeatureLangPackage.SET_VERSION_RANGE:
				sequence_SetVersionRange(context, (SetVersionRange) semanticObject); 
				return; 
			case FeatureLangPackage.UPDATE_ACTION:
				sequence_UpdateAction(context, (UpdateAction) semanticObject); 
				return; 
			case FeatureLangPackage.UPDATE_ATTRIBUTE_DATATYPE:
				sequence_UpdateAttributeDatatype(context, (UpdateAttributeDatatype) semanticObject); 
				return; 
			case FeatureLangPackage.UPDATE_ATTRIBUTE_IDENTIFIER:
				sequence_UpdateAttributeIdentifier(context, (UpdateAttributeIdentifier) semanticObject); 
				return; 
			case FeatureLangPackage.UPDATE_ATTRIBUTE_VALUE:
				sequence_UpdateAttributeValue(context, (UpdateAttributeValue) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * <pre>
	 * Contexts:
	 *     Action returns Action
	 *
	 * Constraint:
	 *     (type=AttributeAction | type=AssociationAction | type=InheritanceAction | type=CompositionAction)
	 * </pre>
	 */
	protected void sequence_Action(ISerializationContext context, de.tud.st.featurelang.featureLang.Action semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     AssociationAction returns AssociationAction
	 *
	 * Constraint:
	 *     (create=CreateAssociation | (name=ID edit=EditAssociation))
	 * </pre>
	 */
	protected void sequence_AssociationAction(ISerializationContext context, AssociationAction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     AttributeAction returns AttributeAction
	 *
	 * Constraint:
	 *     (attribute=Attribute type=Datatype? value=AttributeValue?)
	 * </pre>
	 */
	protected void sequence_AttributeAction(ISerializationContext context, AttributeAction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Attribute returns Attribute
	 *
	 * Constraint:
	 *     name=ID
	 * </pre>
	 */
	protected void sequence_Attribute(ISerializationContext context, Attribute semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FeatureLangPackage.Literals.ATTRIBUTE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FeatureLangPackage.Literals.ATTRIBUTE__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAttributeAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Statement returns ChangeStatement
	 *     ChangeStatement returns ChangeStatement
	 *
	 * Constraint:
	 *     (((target=Class (priority=Priority negation?='not'?)?) | (negation?='remove'? target=Class)) (action=Action | update=UpdateAction))
	 * </pre>
	 */
	protected void sequence_ChangeStatement(ISerializationContext context, ChangeStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Class returns Class
	 *
	 * Constraint:
	 *     (abstraction=Abstraction? name=ID)
	 * </pre>
	 */
	protected void sequence_Class(ISerializationContext context, de.tud.st.featurelang.featureLang.Class semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     CompositionAction returns CompositionAction
	 *
	 * Constraint:
	 *     (create=CreateComposition | edit=EditComposition)
	 * </pre>
	 */
	protected void sequence_CompositionAction(ISerializationContext context, CompositionAction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     CreateAssociation returns CreateAssociation
	 *
	 * Constraint:
	 *     (target=Class relation=ID)
	 * </pre>
	 */
	protected void sequence_CreateAssociation(ISerializationContext context, CreateAssociation semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FeatureLangPackage.Literals.CREATE_ASSOCIATION__TARGET) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FeatureLangPackage.Literals.CREATE_ASSOCIATION__TARGET));
			if (transientValues.isValueTransient(semanticObject, FeatureLangPackage.Literals.CREATE_ASSOCIATION__RELATION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FeatureLangPackage.Literals.CREATE_ASSOCIATION__RELATION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCreateAssociationAccess().getTargetClassParserRuleCall_2_0(), semanticObject.getTarget());
		feeder.accept(grammarAccess.getCreateAssociationAccess().getRelationIDTerminalRuleCall_4_0(), semanticObject.getRelation());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     CreateComposition returns CreateComposition
	 *
	 * Constraint:
	 *     (target=Class relation=ID (priority=Priority publicity=Publicity)?)
	 * </pre>
	 */
	protected void sequence_CreateComposition(ISerializationContext context, CreateComposition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Statement returns CreationStatement
	 *     CreationStatement returns CreationStatement
	 *
	 * Constraint:
	 *     ((classElement=Class priority=Priority negation?='not'?) | (negation?='delete'? classElement=Class))
	 * </pre>
	 */
	protected void sequence_CreationStatement(ISerializationContext context, CreationStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     EditAssociation returns EditAssociation
	 *
	 * Constraint:
	 *     (type=SetCompatible | type=SetVersionRange | type=SetVariant | type=SetRightOpen | type=SetLeftOpen)
	 * </pre>
	 */
	protected void sequence_EditAssociation(ISerializationContext context, EditAssociation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     EditComposition returns EditComposition
	 *
	 * Constraint:
	 *     (compositionName=ID publicity=Publicity)
	 * </pre>
	 */
	protected void sequence_EditComposition(ISerializationContext context, EditComposition semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FeatureLangPackage.Literals.EDIT_COMPOSITION__COMPOSITION_NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FeatureLangPackage.Literals.EDIT_COMPOSITION__COMPOSITION_NAME));
			if (transientValues.isValueTransient(semanticObject, FeatureLangPackage.Literals.EDIT_COMPOSITION__PUBLICITY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FeatureLangPackage.Literals.EDIT_COMPOSITION__PUBLICITY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEditCompositionAccess().getCompositionNameIDTerminalRuleCall_2_0(), semanticObject.getCompositionName());
		feeder.accept(grammarAccess.getEditCompositionAccess().getPublicityPublicityEnumRuleCall_5_0(), semanticObject.getPublicity());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     FeatureRequest returns FeatureRequest
	 *
	 * Constraint:
	 *     statements+=Statement+
	 * </pre>
	 */
	protected void sequence_FeatureRequest(ISerializationContext context, FeatureRequest semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Identifier returns Identifier
	 *
	 * Constraint:
	 *     (value=IdentifierValue name=ID)
	 * </pre>
	 */
	protected void sequence_Identifier(ISerializationContext context, Identifier semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FeatureLangPackage.Literals.IDENTIFIER__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FeatureLangPackage.Literals.IDENTIFIER__VALUE));
			if (transientValues.isValueTransient(semanticObject, FeatureLangPackage.Literals.IDENTIFIER__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FeatureLangPackage.Literals.IDENTIFIER__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getIdentifierAccess().getValueIdentifierValueEnumRuleCall_0_0(), semanticObject.getValue());
		feeder.accept(grammarAccess.getIdentifierAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     InheritanceAction returns InheritanceAction
	 *
	 * Constraint:
	 *     parent=Class
	 * </pre>
	 */
	protected void sequence_InheritanceAction(ISerializationContext context, InheritanceAction semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FeatureLangPackage.Literals.INHERITANCE_ACTION__PARENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FeatureLangPackage.Literals.INHERITANCE_ACTION__PARENT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getInheritanceActionAccess().getParentClassParserRuleCall_2_0(), semanticObject.getParent());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Priority returns Priority
	 *
	 * Constraint:
	 *     priority=PriorityValue
	 * </pre>
	 */
	protected void sequence_Priority(ISerializationContext context, Priority semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FeatureLangPackage.Literals.PRIORITY__PRIORITY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FeatureLangPackage.Literals.PRIORITY__PRIORITY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPriorityAccess().getPriorityPriorityValueEnumRuleCall_0(), semanticObject.getPriority());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     SetCompatible returns SetCompatible
	 *
	 * Constraint:
	 *     name=DATE
	 * </pre>
	 */
	protected void sequence_SetCompatible(ISerializationContext context, SetCompatible semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FeatureLangPackage.Literals.SET_COMPATIBLE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FeatureLangPackage.Literals.SET_COMPATIBLE__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSetCompatibleAccess().getNameDATETerminalRuleCall_3_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     SetLeftOpen returns SetLeftOpen
	 *
	 * Constraint:
	 *     date=DATE
	 * </pre>
	 */
	protected void sequence_SetLeftOpen(ISerializationContext context, SetLeftOpen semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FeatureLangPackage.Literals.SET_LEFT_OPEN__DATE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FeatureLangPackage.Literals.SET_LEFT_OPEN__DATE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSetLeftOpenAccess().getDateDATETerminalRuleCall_3_0(), semanticObject.getDate());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     SetRightOpen returns SetRightOpen
	 *
	 * Constraint:
	 *     date=DATE
	 * </pre>
	 */
	protected void sequence_SetRightOpen(ISerializationContext context, SetRightOpen semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FeatureLangPackage.Literals.SET_RIGHT_OPEN__DATE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FeatureLangPackage.Literals.SET_RIGHT_OPEN__DATE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSetRightOpenAccess().getDateDATETerminalRuleCall_3_0(), semanticObject.getDate());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     SetVariant returns SetVariant
	 *
	 * Constraint:
	 *     name=DATE
	 * </pre>
	 */
	protected void sequence_SetVariant(ISerializationContext context, SetVariant semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FeatureLangPackage.Literals.SET_VARIANT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FeatureLangPackage.Literals.SET_VARIANT__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSetVariantAccess().getNameDATETerminalRuleCall_5_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     SetVersionRange returns SetVersionRange
	 *
	 * Constraint:
	 *     (start=DATE end=DATE)
	 * </pre>
	 */
	protected void sequence_SetVersionRange(ISerializationContext context, SetVersionRange semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FeatureLangPackage.Literals.SET_VERSION_RANGE__START) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FeatureLangPackage.Literals.SET_VERSION_RANGE__START));
			if (transientValues.isValueTransient(semanticObject, FeatureLangPackage.Literals.SET_VERSION_RANGE__END) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FeatureLangPackage.Literals.SET_VERSION_RANGE__END));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSetVersionRangeAccess().getStartDATETerminalRuleCall_4_0(), semanticObject.getStart());
		feeder.accept(grammarAccess.getSetVersionRangeAccess().getEndDATETerminalRuleCall_6_0(), semanticObject.getEnd());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     UpdateAction returns UpdateAction
	 *
	 * Constraint:
	 *     (attribute=Attribute priority=Priority (datatype=UpdateAttributeDatatype | identifier=UpdateAttributeIdentifier | value=UpdateAttributeValue))
	 * </pre>
	 */
	protected void sequence_UpdateAction(ISerializationContext context, UpdateAction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     UpdateAttributeDatatype returns UpdateAttributeDatatype
	 *
	 * Constraint:
	 *     (type=Datatype oldType=Datatype)
	 * </pre>
	 */
	protected void sequence_UpdateAttributeDatatype(ISerializationContext context, UpdateAttributeDatatype semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FeatureLangPackage.Literals.UPDATE_ATTRIBUTE_DATATYPE__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FeatureLangPackage.Literals.UPDATE_ATTRIBUTE_DATATYPE__TYPE));
			if (transientValues.isValueTransient(semanticObject, FeatureLangPackage.Literals.UPDATE_ATTRIBUTE_DATATYPE__OLD_TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FeatureLangPackage.Literals.UPDATE_ATTRIBUTE_DATATYPE__OLD_TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getUpdateAttributeDatatypeAccess().getTypeDatatypeEnumRuleCall_2_0(), semanticObject.getType());
		feeder.accept(grammarAccess.getUpdateAttributeDatatypeAccess().getOldTypeDatatypeEnumRuleCall_5_0(), semanticObject.getOldType());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     UpdateAttributeIdentifier returns UpdateAttributeIdentifier
	 *
	 * Constraint:
	 *     (identifier=Identifier oldIdentifier=Identifier)
	 * </pre>
	 */
	protected void sequence_UpdateAttributeIdentifier(ISerializationContext context, UpdateAttributeIdentifier semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FeatureLangPackage.Literals.UPDATE_ATTRIBUTE_IDENTIFIER__IDENTIFIER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FeatureLangPackage.Literals.UPDATE_ATTRIBUTE_IDENTIFIER__IDENTIFIER));
			if (transientValues.isValueTransient(semanticObject, FeatureLangPackage.Literals.UPDATE_ATTRIBUTE_IDENTIFIER__OLD_IDENTIFIER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FeatureLangPackage.Literals.UPDATE_ATTRIBUTE_IDENTIFIER__OLD_IDENTIFIER));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getUpdateAttributeIdentifierAccess().getIdentifierIdentifierParserRuleCall_2_0(), semanticObject.getIdentifier());
		feeder.accept(grammarAccess.getUpdateAttributeIdentifierAccess().getOldIdentifierIdentifierParserRuleCall_5_0(), semanticObject.getOldIdentifier());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     UpdateAttributeValue returns UpdateAttributeValue
	 *
	 * Constraint:
	 *     (value=AttributeValue oldValue=AttributeValue)
	 * </pre>
	 */
	protected void sequence_UpdateAttributeValue(ISerializationContext context, UpdateAttributeValue semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FeatureLangPackage.Literals.UPDATE_ATTRIBUTE_VALUE__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FeatureLangPackage.Literals.UPDATE_ATTRIBUTE_VALUE__VALUE));
			if (transientValues.isValueTransient(semanticObject, FeatureLangPackage.Literals.UPDATE_ATTRIBUTE_VALUE__OLD_VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FeatureLangPackage.Literals.UPDATE_ATTRIBUTE_VALUE__OLD_VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getUpdateAttributeValueAccess().getValueAttributeValueParserRuleCall_3_0(), semanticObject.getValue());
		feeder.accept(grammarAccess.getUpdateAttributeValueAccess().getOldValueAttributeValueParserRuleCall_6_0(), semanticObject.getOldValue());
		feeder.finish();
	}
	
	
}
